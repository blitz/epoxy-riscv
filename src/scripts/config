#!/usr/bin/env python3

import argparse
import base64
import json
import os
import string
import struct

from elftools.elf.elffile import ELFFile

def get_elf_entry(name):
    """Return the entry point of an ELF binary."""
    with open(name, "rb") as f:
        return ELFFile(f).header["e_entry"]

header_template = string.Template("""// Automatically generated.
#pragma once

#include "config_types.hpp"
#include "process.hpp"
#include "thread.hpp"

extern kobject kobjects[$kobject_count];
extern thread threads[$thread_count];
extern process processes[$process_count];
""")

source_template = string.Template("""// Automatically generated

#include "$header_name"

kobject kobjects[] { $kobject_init };
$capset_init
process processes[$process_count] {
    $process_init
};
thread threads[$thread_count] {
    $thread_init
};
""")


def check_sequential(l, key, name):
    for i in range(0, len(l)):
        if i != l[i][key]:
            raise "{} list is not sequential".format(name)


def get_processes(app):
    """Return all process descriptions"""
    processes = sorted(app["processes"], key=lambda p: p["pid"])
    check_sequential(processes, "pid", "Process")

    for p in processes:
        p["user_entry"] = get_elf_entry(p["binary"])

    return processes


def get_kobjs(app):
    """Return all capabilities"""
    kobjs = sorted(app["kobjects"], key=lambda g: g["gid"])
    check_sequential(kobjs, "gid", "Kernel object")
    return kobjs


def process_capset_name(process):
    return "p{}_capability_set".format(process["pid"])


def string_to_file(string, ofile):
    with open(ofile, "w") as f:
        f.write(string)


def generate_config(machine, app, output_cpp, output_hpp):
    kobj_impl_init = ""
    capset_impl_init = ""
    process_impl_init = ""
    thread_impl_init = ""

    for p in get_processes(app):
        capset_impl_init += "static const kobj_id_t {}[] = {{{}}};\n".format(
            process_capset_name(p), ",".join(
                str(c) for c in p["capabilities"]))
        process_impl_init += "{{{},{{{},{}}}}},".format(
            p["pid"], str(len(p["capabilities"])), process_capset_name(p))
        thread_impl_init += "{{&processes[{}], {}ULL}},".format(
            p["pid"], hex(p["user_entry"]))

    for k in get_kobjs(app):
        kobj_impl_init += "{" + "kobject_type::{}".format(k["type"]) + "},"

    string_to_file(
        header_template.substitute(
            kobject_count=str(len(get_kobjs(app))),
            process_count=str(len(get_processes(app))),
            thread_count=str(len(get_processes(app))),
            processor_count=1), output_hpp)

    string_to_file(
        source_template.substitute(
            header_name=os.path.basename(output_hpp),
            kobject_init=kobj_impl_init,
            capset_init=capset_impl_init,
            process_count=str(len(get_processes(app))),
            process_init=process_impl_init,
            thread_count=str(len(get_processes(app))),
            thread_init=thread_impl_init,
            processor_count=1), output_cpp)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="""
    Parse a machine and application description and generate the kernel configuration.
    """)
    parser.add_argument(
        '--machine', help='The machine description in JSON', required=True)
    parser.add_argument(
        '--application',
        help='The application description in JSON',
        required=True)
    parser.add_argument(
        '--output-cpp',
        help='The C++ implementation file to generate',
        required=True)
    parser.add_argument(
        '--output-hpp', help='The C++ header file to generate', required=True)

    args = parser.parse_args()

    with open(args.machine, "rb") as machine_file:
        machine_json = json.loads(machine_file.read())

    with open(args.application, "rb") as app_file:
        app_json = json.loads(app_file.read())

    generate_config(machine_json, app_json, args.output_cpp, args.output_hpp)
